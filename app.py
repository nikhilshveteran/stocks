# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ec3K-UcquGJWPLycpR7odMcWyXhubKtZ
"""

import subprocess
        multi=True,
        value=default_stocks  # Set default selection
    ),
    html.Label("Rearrange Graphs:"),
    dcc.Dropdown(
        id='graph-layout',
        options=[{'label': name, 'value': name} for name in ["Risk-Return", "ROI Bar", "Historical Trends", "Investment Simulation", "Future Prediction"]],
        multi=True,
        value=["Risk-Return", "ROI Bar", "Historical Trends", "Investment Simulation", "Future Prediction"]
    ),
    html.Div(id='graph-container')
])

# Step 7: Callbacks to update graphs dynamically
@app.callback(
    Output('graph-container', 'children'),
    Input('graph-layout', 'value'),
    Input('stock-dropdown', 'value')
)
def update_graphs(selected_graphs, selected_stocks):
    if not selected_stocks:
        selected_stocks = default_stocks  # Ensure there are selected stocks
    graphs = []

    if "Risk-Return" in selected_graphs:
        fig = px.scatter(performance_df, x='Volatility', y='ROI', text='Stock', title="Risk vs Return")
        graphs.append(dcc.Graph(figure=fig))

    if "ROI Bar" in selected_graphs:
        bucket_df = performance_df[performance_df['Stock'].isin(selected_stocks)]
        if not bucket_df.empty:
            fig = px.bar(bucket_df, x='Stock', y='ROI', title="Selected Stocks ROI", color='Stock')
            graphs.append(dcc.Graph(figure=fig))

    if "Historical Trends" in selected_graphs:
        available_stocks = [stock for stock in selected_stocks if stock in df.columns]
        if available_stocks:
            trend_df = df[available_stocks].copy()
            fig = px.line(trend_df, x=trend_df.index, y=trend_df.columns, title="Historical Trends")
            graphs.append(dcc.Graph(figure=fig))

    if "Investment Simulation" in selected_graphs:
        sim_results = {}
        initial_investment = 10000
        for stock in selected_stocks:
            if stock in returns_df.columns:
                sim_results[stock] = (initial_investment * (1 + returns_df[stock]).cumprod())
        if sim_results:
            sim_df = pd.DataFrame(sim_results)
            fig = px.line(sim_df, x=sim_df.index, y=sim_df.columns, title="Investment Simulation")
            graphs.append(dcc.Graph(figure=fig))

    if "Future Prediction" in selected_graphs:
        predictions = {}
        for stock in selected_stocks:
            if stock in df.columns and not df[stock].isnull().all():
                model = pm.auto_arima(df[stock].dropna(), seasonal=False, suppress_warnings=True)
                future_dates = pd.date_range(df.index[-1], periods=30, freq='B')
                forecast, _ = model.predict(n_periods=30, return_conf_int=True)
                predictions[stock] = pd.Series(forecast, index=future_dates)
        if predictions:
            pred_df = pd.DataFrame(predictions)
            fig = px.line(pred_df, x=pred_df.index, y=pred_df.columns, title="Future Predictions (Next 30 Days)")
            graphs.append(dcc.Graph(figure=fig))

    return graphs if graphs else [html.P("No data available for selected stocks.")]  # Show message if no graphs

# Step 8: Expose the Dash App via ngrok for Public Access
port = 8051
public_url = ngrok.connect(port).public_url
print(f"Access your app at: {public_url}")

if __name__ == '__main__':
    app.run_server(host='0.0.0.0', port=port, debug=True)

import subprocess
@app.callback(
    Output('graph-container', 'children'),
    Input('graph-layout', 'value'),
    Input('stock-dropdown', 'value')
)
def update_graphs(selected_graphs, selected_stocks):
    if not selected_stocks:
        selected_stocks = default_stocks  # Ensure there are selected stocks
    graphs = []

    if "Risk-Return" in selected_graphs:
        fig = px.scatter(performance_df, x='Volatility', y='ROI', text='Stock', title="Risk vs Return")
        graphs.append(dcc.Graph(figure=fig))

    if "ROI Bar" in selected_graphs:
        bucket_df = performance_df[performance_df['Stock'].isin(selected_stocks)]
        if not bucket_df.empty:
            fig = px.bar(bucket_df, x='Stock', y='ROI', title="Selected Stocks ROI", color='Stock')
            graphs.append(dcc.Graph(figure=fig))

    if "Historical Trends" in selected_graphs:
        available_stocks = [stock for stock in selected_stocks if stock in df.columns]
        if available_stocks:
            trend_df = df[available_stocks]
            fig = px.line(trend_df, x=trend_df.index, y=trend_df.columns, title="Historical Trends")
            graphs.append(dcc.Graph(figure=fig))

    if "Investment Simulation" in selected_graphs:
        sim_results = {}
        initial_investment = 10000
        for stock in selected_stocks:
            if stock in returns_df.columns:
                sim_results[stock] = (initial_investment * (1 + returns_df[stock]).cumprod())
        if sim_results:
            sim_df = pd.DataFrame(sim_results)
            fig = px.line(sim_df, x=sim_df.index, y=sim_df.columns, title="Investment Simulation")
            graphs.append(dcc.Graph(figure=fig))

    if "Future Prediction" in selected_graphs:
        predictions = {}
        for stock in selected_stocks:
            if stock in df.columns and not df[stock].isnull().all():
                try:
                    model = pm.auto_arima(df[stock].dropna(), seasonal=False, suppress_warnings=True)
                    future_dates = pd.date_range(df.index[-1], periods=30, freq='B')
                    forecast, _ = model.predict(n_periods=30, return_conf_int=True)
                    predictions[stock] = pd.Series(forecast, index=future_dates)
                except Exception as e:
                    print(f"Prediction error for {stock}: {e}")
        if predictions:
            pred_df = pd.DataFrame(predictions)
            fig = px.line(pred_df, x=pred_df.index, y=pred_df.columns, title="Future Predictions (Next 30 Days)")
            graphs.append(dcc.Graph(figure=fig))

    return graphs if graphs else [html.P("No data available for selected stocks.")]  # Show message if no graphs

# Step 8: Expose the Dash App via ngrok for Public Access
port = 8051
public_url = ngrok.connect(port).public_url
print(f"Access your app at: {public_url}")

if __name__ == '__main__':
    app.run_server(host='0.0.0.0', port=port, debug=True)

import subprocess
    html.Div(id='graph-container')
])

# Step 7: Callbacks to update graphs dynamically
@app.callback(
    Output('graph-container', 'children'),
    Input('graph-layout', 'value'),
    Input('stock-dropdown', 'value')
)
def update_graphs(selected_graphs, selected_stocks):
    if not selected_stocks:
        selected_stocks = default_stocks  # Ensure there are selected stocks
    graphs = []

    if "Risk-Return" in selected_graphs:
        fig = px.scatter(performance_df, x='Volatility', y='ROI', text='Stock', title="Risk vs Return")
        graphs.append(dcc.Graph(figure=fig))

    if "ROI Bar" in selected_graphs:
        bucket_df = performance_df[performance_df['Stock'].isin(selected_stocks)]
        if not bucket_df.empty:
            fig = px.bar(bucket_df, x='Stock', y='ROI', title="Selected Stocks ROI", color='Stock')
            graphs.append(dcc.Graph(figure=fig))

    if "Historical Trends" in selected_graphs:
        available_stocks = [stock for stock in selected_stocks if stock in df.columns]
        if available_stocks:
            trend_df = df[available_stocks]
            fig = px.line(trend_df, x=trend_df.index, y=trend_df.columns, title="Historical Trends")
            graphs.append(dcc.Graph(figure=fig))

    if "Investment Simulation" in selected_graphs:
        sim_results = {}
        initial_investment = 10000
        for stock in selected_stocks:
            if stock in returns_df.columns:
                sim_results[stock] = (initial_investment * (1 + returns_df[stock]).cumprod())
        if sim_results:
            sim_df = pd.DataFrame(sim_results)
            fig = px.line(sim_df, x=sim_df.index, y=sim_df.columns, title="Investment Simulation")
            graphs.append(dcc.Graph(figure=fig))

    if "Future Prediction" in selected_graphs:
        predictions = {}
        for stock in selected_stocks:
            if stock in df.columns and not df[stock].isnull().all():
                try:
                    model = pm.auto_arima(df[stock].dropna(), seasonal=False, suppress_warnings=True)
                    future_dates = pd.date_range(df.index[-1], periods=30, freq='B')
                    forecast, _ = model.predict(n_periods=30, return_conf_int=True)
                    predictions[stock] = pd.Series(forecast, index=future_dates)
                except Exception as e:
                    print(f"Prediction error for {stock}: {e}")
        if predictions:
            pred_df = pd.DataFrame(predictions)
            fig = px.line(pred_df, x=pred_df.index, y=pred_df.columns, title="Future Predictions (Next 30 Days)")
            graphs.append(dcc.Graph(figure=fig))

    return graphs if graphs else [html.P("No data available for selected stocks.")]  # Show message if no graphs

# Step 8: Expose the Dash App via ngrok for Public Access
port = 8051
public_url = ngrok.connect(port).public_url
print(f"Access your app at: {public_url}")

if __name__ == '__main__':
    app.run_server(host='0.0.0.0', port=port, debug=True)

import subprocess

# Step 1: Install required packages before importing
subprocess.run(['pip', 'install', 'yfinance', 'dash', 'plotly', 'pyngrok', 'pmdarima'])

import pandas as pd
import numpy as np
import yfinance as yf
import plotly.express as px
import plotly.graph_objects as go
from dash import Dash, dcc, html, Input, Output
from pyngrok import ngrok
import os
import pmdarima as pm

# Step 2: Kill existing ngrok processes to avoid tunnel limit errors
subprocess.run(['pkill', '-f', 'ngrok'])

# Step 3: Set up ngrok authentication securely
authtoken = input("Enter your ngrok authtoken: ")  # Prompt user for token
ngrok.set_auth_token(authtoken)

# Step 4: Fetch Stock Data (Now fetching all NIFTY50 stocks)
nifty50_stocks = [
    "RELIANCE.NS", "TCS.NS", "INFY.NS", "HDFCBANK.NS", "ICICIBANK.NS", "BAJFINANCE.NS", "HCLTECH.NS", "LT.NS",
    "SBIN.NS", "ASIANPAINT.NS", "AXISBANK.NS", "DMART.NS", "MARUTI.NS", "ULTRACEMCO.NS", "TITAN.NS",
    "SUNPHARMA.NS", "M&M.NS", "NESTLEIND.NS", "WIPRO.NS", "ADANIGREEN.NS", "TATASTEEL.NS", "JSWSTEEL.NS",
    "POWERGRID.NS", "ONGC.NS", "NTPC.NS", "COALINDIA.NS", "BPCL.NS", "IOC.NS", "TECHM.NS", "INDUSINDBK.NS"
]
df = yf.download(nifty50_stocks, start="2020-01-01", end="2024-12-31")["Close"].dropna()

# Step 5: Calculate stock returns and volatility
returns_df = df.pct_change().dropna()
roi = returns_df.mean() * 252  # Annualized ROI
volatility = returns_df.std() * np.sqrt(252)  # Annualized volatility
performance_df = pd.DataFrame({'Stock': roi.index, 'ROI': roi.values, 'Volatility': volatility.values})

# Step 6: Create Dash App (For Google Colab and Local Machines)
app = Dash(__name__)
default_stocks = ["RELIANCE.NS", "TCS.NS"]  # Default stocks to show initially

app.layout = html.Div([
    html.H1("Stock Investment Analysis"),
    html.Label("Select Stocks to Analyze:"),
    dcc.Dropdown(
        id='stock-dropdown',
        options=[{'label': stock, 'value': stock} for stock in performance_df['Stock']],
        multi=True,
        value=default_stocks  # Set default selection
    ),
    html.Label("Rearrange Graphs:"),
    dcc.Dropdown(
        id='graph-layout',
        options=[{'label': name, 'value': name} for name in ["Risk-Return", "ROI Bar", "Historical Trends", "Investment Simulation", "Future Prediction"]],
        multi=True,
        value=["Risk-Return", "ROI Bar", "Historical Trends", "Investment Simulation", "Future Prediction"]
    ),
    html.Div(id='graph-container')
])

# Step 7: Callbacks to update graphs dynamically
@app.callback(
    Output('graph-container', 'children'),
    Input('graph-layout', 'value'),
    Input('stock-dropdown', 'value')
)
def update_graphs(selected_graphs, selected_stocks):
    if not selected_stocks:
        selected_stocks = default_stocks  # Ensure there are selected stocks
    graphs = []

    if "Risk-Return" in selected_graphs:
        fig = px.scatter(performance_df, x='Volatility', y='ROI', text='Stock', title="Risk vs Return")
        graphs.append(dcc.Graph(figure=fig))

    if "ROI Bar" in selected_graphs:
        bucket_df = performance_df[performance_df['Stock'].isin(selected_stocks)]
        if not bucket_df.empty:
            fig = px.bar(bucket_df, x='Stock', y='ROI', title="Selected Stocks ROI", color='Stock')
            graphs.append(dcc.Graph(figure=fig))

    if "Historical Trends" in selected_graphs:
        available_stocks = [stock for stock in selected_stocks if stock in df.columns]
        if available_stocks:
            trend_df = df[available_stocks]
            fig = px.line(trend_df, x=trend_df.index, y=trend_df.columns, title="Historical Trends")
            graphs.append(dcc.Graph(figure=fig))

    if "Investment Simulation" in selected_graphs:
        sim_results = {}
        initial_investment = 10000
        for stock in selected_stocks:
            if stock in returns_df.columns:
                sim_results[stock] = (initial_investment * (1 + returns_df[stock]).cumprod())
        if sim_results:
            sim_df = pd.DataFrame(sim_results)
            fig = px.line(sim_df, x=sim_df.index, y=sim_df.columns, title="Investment Simulation")
            graphs.append(dcc.Graph(figure=fig))

    if "Future Prediction" in selected_graphs:
        predictions = {}
        for stock in selected_stocks:
            if stock in df.columns and not df[stock].isnull().all():
                try:
                    model = pm.auto_arima(df[stock].dropna(), seasonal=False, suppress_warnings=True)
                    future_dates = pd.date_range(df.index[-1], periods=30, freq='B')
                    forecast, _ = model.predict(n_periods=30, return_conf_int=True)
                    predictions[stock] = pd.Series(forecast, index=future_dates)
                except Exception as e:
                    print(f"Prediction error for {stock}: {e}")
        if predictions:
            pred_df = pd.DataFrame(predictions)
            fig = px.line(pred_df, x=pred_df.index, y=pred_df.columns, title="Future Predictions (Next 30 Days)")
            graphs.append(dcc.Graph(figure=fig))

    return graphs if graphs else [html.P("No data available for selected stocks.")]  # Show message if no graphs

# Step 8: Expose the Dash App via ngrok for Public Access
port = 8051
public_url = ngrok.connect(port).public_url
print(f"Access your app at: {public_url}")

if __name__ == '__main__':
    app.run_server(host='0.0.0.0', port=port, debug=True)

import subprocess

# Step 1: Install required packages before importing
subprocess.run(['pip', 'install', 'yfinance', 'dash', 'plotly', 'pmdarima', 'gunicorn'])

import pandas as pd
import numpy as np
import yfinance as yf
import plotly.express as px
import plotly.graph_objects as go
from dash import Dash, dcc, html, Input, Output
import os
import pmdarima as pm

# Step 2: Fetch Stock Data (Now fetching all NIFTY50 stocks)
nifty50_stocks = [
    "RELIANCE.NS", "TCS.NS", "INFY.NS", "HDFCBANK.NS", "ICICIBANK.NS", "BAJFINANCE.NS", "HCLTECH.NS", "LT.NS",
    "SBIN.NS", "ASIANPAINT.NS", "AXISBANK.NS", "DMART.NS", "MARUTI.NS", "ULTRACEMCO.NS", "TITAN.NS",
    "SUNPHARMA.NS", "M&M.NS", "NESTLEIND.NS", "WIPRO.NS", "ADANIGREEN.NS", "TATASTEEL.NS", "JSWSTEEL.NS",
    "POWERGRID.NS", "ONGC.NS", "NTPC.NS", "COALINDIA.NS", "BPCL.NS", "IOC.NS", "TECHM.NS", "INDUSINDBK.NS"
]
df = yf.download(nifty50_stocks, start="2020-01-01", end="2024-12-31")["Close"].dropna()

# Step 3: Calculate stock returns and volatility
returns_df = df.pct_change().dropna()
roi = returns_df.mean() * 252  # Annualized ROI
volatility = returns_df.std() * np.sqrt(252)  # Annualized volatility
performance_df = pd.DataFrame({'Stock': roi.index, 'ROI': roi.values, 'Volatility': volatility.values})

# Step 4: Create Dash App for Render Deployment
app = Dash(__name__)
default_stocks = ["RELIANCE.NS", "TCS.NS"]  # Default stocks to show initially

app.layout = html.Div([
    html.H1("Stock Investment Analysis"),
    html.Label("Select Stocks to Analyze:"),
    dcc.Dropdown(
        id='stock-dropdown',
        options=[{'label': stock, 'value': stock} for stock in performance_df['Stock']],
        multi=True,
        value=default_stocks  # Set default selection
    ),
    html.Label("Rearrange Graphs:"),
    dcc.Dropdown(
        id='graph-layout',
        options=[{'label': name, 'value': name} for name in ["Risk-Return", "ROI Bar", "Historical Trends", "Investment Simulation", "Future Prediction"]],
        multi=True,
        value=["Risk-Return", "ROI Bar", "Historical Trends", "Investment Simulation", "Future Prediction"]
    ),
    html.Div(id='graph-container')
])

# Step 5: Callbacks to update graphs dynamically
@app.callback(
    Output('graph-container', 'children'),
    Input('graph-layout', 'value'),
    Input('stock-dropdown', 'value')
)
def update_graphs(selected_graphs, selected_stocks):
    if not selected_stocks:
        selected_stocks = default_stocks  # Ensure there are selected stocks
    graphs = []

    if "Risk-Return" in selected_graphs:
        fig = px.scatter(performance_df, x='Volatility', y='ROI', text='Stock', title="Risk vs Return")
        graphs.append(dcc.Graph(figure=fig))

    if "ROI Bar" in selected_graphs:
        bucket_df = performance_df[performance_df['Stock'].isin(selected_stocks)]
        if not bucket_df.empty:
            fig = px.bar(bucket_df, x='Stock', y='ROI', title="Selected Stocks ROI", color='Stock')
            graphs.append(dcc.Graph(figure=fig))

    if "Historical Trends" in selected_graphs:
        available_stocks = [stock for stock in selected_stocks if stock in df.columns]
        if available_stocks:
            trend_df = df[available_stocks]
            fig = px.line(trend_df, x=trend_df.index, y=trend_df.columns, title="Historical Trends")
            graphs.append(dcc.Graph(figure=fig))

    if "Investment Simulation" in selected_graphs:
        sim_results = {}
        initial_investment = 10000
        for stock in selected_stocks:
            if stock in returns_df.columns:
                sim_results[stock] = (initial_investment * (1 + returns_df[stock]).cumprod())
        if sim_results:
            sim_df = pd.DataFrame(sim_results)
            fig = px.line(sim_df, x=sim_df.index, y=sim_df.columns, title="Investment Simulation")
            graphs.append(dcc.Graph(figure=fig))

    return graphs if graphs else [html.P("No data available for selected stocks.")]  # Show message if no graphs

# Step 6: Run the Dash App on Render
if __name__ == '__main__':
    app.run_server(host='0.0.0.0', port=10000, debug=True)

import subprocess
import os

# Step 1: Install required packages before importing
subprocess.run(['pip', 'install', 'yfinance', 'dash', 'plotly', 'pmdarima', 'gunicorn'])

import pandas as pd
import numpy as np
import yfinance as yf
import plotly.express as px
import plotly.graph_objects as go
from dash import Dash, dcc, html, Input, Output
import pmdarima as pm

# Step 2: Create Dash App for Render Deployment
app = Dash(__name__)
server = app.server  # Required for gunicorn on Render

default_stocks = ["RELIANCE.NS", "TCS.NS"]  # Default stocks to show initially

app.layout = html.Div([
    html.H1("Stock Investment Analysis"),
    html.Label("Select Stocks to Analyze:"),
    dcc.Dropdown(
        id='stock-dropdown',
        options=[],  # Will be updated after data fetch
        multi=True,
        value=default_stocks
    ),
    html.Label("Rearrange Graphs:"),
    dcc.Dropdown(
        id='graph-layout',
        options=[{'label': name, 'value': name} for name in ["Risk-Return", "ROI Bar", "Historical Trends", "Investment Simulation"]],
        multi=True,
        value=["Risk-Return", "ROI Bar", "Historical Trends", "Investment Simulation"]
    ),
    html.Div(id='graph-container')
])

# Step 3: Fetch Stock Data Only When the App Runs
@app.callback(
    Output('stock-dropdown', 'options'),
    Input('stock-dropdown', 'value')
)
def load_data(value):
    nifty50_stocks = [
        "RELIANCE.NS", "TCS.NS", "INFY.NS", "HDFCBANK.NS", "ICICIBANK.NS", "BAJFINANCE.NS", "HCLTECH.NS", "LT.NS",
        "SBIN.NS", "ASIANPAINT.NS", "AXISBANK.NS", "DMART.NS", "MARUTI.NS", "ULTRACEMCO.NS", "TITAN.NS",
        "SUNPHARMA.NS", "M&M.NS", "NESTLEIND.NS", "WIPRO.NS", "ADANIGREEN.NS", "TATASTEEL.NS", "JSWSTEEL.NS",
        "POWERGRID.NS", "ONGC.NS", "NTPC.NS", "COALINDIA.NS", "BPCL.NS", "IOC.NS", "TECHM.NS", "INDUSINDBK.NS"
    ]
    df = yf.download(nifty50_stocks, start="2020-01-01", end="2024-12-31")["Close"].dropna()
    returns_df = df.pct_change().dropna()
    roi = returns_df.mean() * 252
    volatility = returns_df.std() * np.sqrt(252)
    global performance_df
    performance_df = pd.DataFrame({'Stock': roi.index, 'ROI': roi.values, 'Volatility': volatility.values})
    return [{'label': stock, 'value': stock} for stock in performance_df['Stock']]

# Step 4: Callbacks to update graphs dynamically
@app.callback(
    Output('graph-container', 'children'),
    Input('graph-layout', 'value'),
    Input('stock-dropdown', 'value')
)
def update_graphs(selected_graphs, selected_stocks):
    if not selected_stocks:
        selected_stocks = default_stocks  # Ensure there are selected stocks
    graphs = []

    if "Risk-Return" in selected_graphs:
        fig = px.scatter(performance_df, x='Volatility', y='ROI', text='Stock', title="Risk vs Return")
        graphs.append(dcc.Graph(figure=fig))

    if "ROI Bar" in selected_graphs:
        bucket_df = performance_df[performance_df['Stock'].isin(selected_stocks)]
        if not bucket_df.empty:
            fig = px.bar(bucket_df, x='Stock', y='ROI', title="Selected Stocks ROI", color='Stock')
            graphs.append(dcc.Graph(figure=fig))

    if "Historical Trends" in selected_graphs:
        available_stocks = [stock for stock in selected_stocks if stock in df.columns]
        if available_stocks:
            trend_df = df[available_stocks]
            fig = px.line(trend_df, x=trend_df.index, y=trend_df.columns, title="Historical Trends")
            graphs.append(dcc.Graph(figure=fig))

    if "Investment Simulation" in selected_graphs:
        sim_results = {}
        initial_investment = 10000
        for stock in selected_stocks:
            if stock in returns_df.columns:
                sim_results[stock] = (initial_investment * (1 + returns_df[stock]).cumprod())
        if sim_results:
            sim_df = pd.DataFrame(sim_results)
            fig = px.line(sim_df, x=sim_df.index, y=sim_df.columns, title="Investment Simulation")
            graphs.append(dcc.Graph(figure=fig))

    return graphs if graphs else [html.P("No data available for selected stocks.")]  # Show message if no graphs

# Step 5: Run the Dash App on Render
if __name__ == '__main__':
    port = int(os.environ.get("PORT", 10000))  # Use Render's assigned port
    app.run_server(host='0.0.0.0', port=port, debug=True)